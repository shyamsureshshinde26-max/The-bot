import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Emoji mapping (letters + digits + punctuation)
encode_map = {
    "a": "ü™ê", "b": "üß©", "c": "üåô", "d": "üêâ", "e": "üîÆ", "f": "ü¶ä",
    "g": "ü¶â", "h": "üêö", "i": "ü¶Ñ", "j": "üßø", "k": "üêæ", "l": "üçÑ",
    "m": "ü™≤", "n": "üêç", "o": "ü¶¢", "p": "ü¶ã", "q": "üêô", "r": "üå∏",
    "s": "üïäÔ∏è", "t": "ü™ª", "u": "üåä", "v": "üî±", "w": "ü™∂", "x": "ü¶Ç",
    "y": "ü¶ö", "z": "üê¢",
    "0": "üé≤", "1": "üéØ", "2": "üéµ", "3": "üé≠", "4": "üßä",
    "5": "üîî", "6": "ü™ô", "7": "ü™Å", "8": "ü™û", "9": "üß∂",
    " ": "üåÄ", ",": "üí†", ".": "üî∏", "!": "üí•", "?": "‚ùì",
    ":": "üîî", ";": "üõéÔ∏è", "'": "ü™û", '"': "üéê", "-": "ü™ö",
    "_": "ü™µ", "(": "ü™¥", ")": "ü™∑"
}

# Create decode map by reversing the encode map
decode_map = {v: k for k, v in encode_map.items()}

def encode_text(text):
    """Convert text to emoji codes using the mapping"""
    if not text:
        return ""
    
    result = ""
    for ch in text.lower():
        if ch in encode_map:
            result += encode_map[ch]
        else:
            # Keep unsupported characters as is
            result += ch
    return result

def decode_text(text):
    """Convert emoji codes back to text using the mapping"""
    if not text:
        return ""
    
    result = ""
    for ch in text:
        if ch in decode_map:
            result += decode_map[ch]
        else:
            # Keep unsupported characters as is
            result += ch
    return result

def is_emoji_text(text):
    """Check if text contains mostly emojis from our decode map"""
    emoji_count = sum(1 for char in text if char in decode_map)
    total_chars = len([c for c in text if c.strip()])  # Ignore whitespace
    if total_chars == 0:
        return False
    return emoji_count / total_chars > 0.7  # 70% or more are emojis

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send welcome message with menu buttons."""
    if update.message:
        keyboard = [
            [InlineKeyboardButton("üîÆ Convert Text to Emoji", callback_data='mode_encode')],
            [InlineKeyboardButton("üìù Convert Emoji to Text", callback_data='mode_decode')],
            [InlineKeyboardButton("üîÑ Auto Convert Mode", callback_data='mode_auto')],
            [InlineKeyboardButton("‚ùì Help", callback_data='help')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "ü§ñ **Text to Emoji Converter Bot**\n\n"
            "Welcome! Choose how you want to use the bot:\n\n"
            "üîÆ **Text to Emoji** - I'll convert your text to secret emoji codes\n"
            "üìù **Emoji to Text** - I'll convert emoji codes back to readable text\n"
            "üîÑ **Auto Mode** - Just send me any text and I'll automatically detect and convert!\n\n"
            "Pick an option below:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

# Store user modes in memory (in production, you'd use a database)
user_modes = {}

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle button presses"""
    query = update.callback_query
    if not query or not query.from_user:
        return
        
    await query.answer()
    user_id = query.from_user.id
    
    if query.data == 'mode_encode':
        user_modes[user_id] = 'encode'
        await query.edit_message_text(
            "üîÆ **Text to Emoji Mode**\n\n"
            "Now just send me any text and I'll convert it to emoji codes!\n\n"
            "Example: Send 'hello world' and I'll reply with emoji codes\n\n"
            "Send /start anytime to change modes.",
            parse_mode='Markdown'
        )
    elif query.data == 'mode_decode':
        user_modes[user_id] = 'decode'
        await query.edit_message_text(
            "üìù **Emoji to Text Mode**\n\n"
            "Now just send me emoji codes and I'll convert them back to text!\n\n"
            "Example: Send 'üêöüîÆüçÑüçÑü¶¢üåÄü™∂ü¶¢üå∏üçÑüêâ' and I'll reply with text\n\n"
            "Send /start anytime to change modes.",
            parse_mode='Markdown'
        )
    elif query.data == 'mode_auto':
        user_modes[user_id] = 'auto'
        await query.edit_message_text(
            "üîÑ **Auto Convert Mode**\n\n"
            "Perfect! Now just send me anything:\n\n"
            "‚Ä¢ Send **text** ‚Üí I'll convert to emoji codes\n"
            "‚Ä¢ Send **emoji codes** ‚Üí I'll convert to text\n\n"
            "I'll automatically detect which type you sent!\n\n"
            "Send /start anytime to change modes.",
            parse_mode='Markdown'
        )
    elif query.data == 'help':
        keyboard = [
            [InlineKeyboardButton("üîô Back to Menu", callback_data='back_to_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "üîß **How to Use This Bot**\n\n"
            "üîÆ **Text to Emoji:** Converts your text into secret emoji codes\n"
            "üìù **Emoji to Text:** Converts emoji codes back to readable text\n"
            "üîÑ **Auto Mode:** Automatically detects and converts both ways\n\n"
            "**Examples:**\n"
            "‚Ä¢ Text: 'hello' ‚Üí Emoji: 'üêöüîÆüçÑüçÑü¶¢'\n"
            "‚Ä¢ Emoji: 'üêöüîÆüçÑüçÑü¶¢' ‚Üí Text: 'hello'\n\n"
            "Just choose a mode and start typing!",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    elif query.data == 'back_to_menu':
        keyboard = [
            [InlineKeyboardButton("üîÆ Convert Text to Emoji", callback_data='mode_encode')],
            [InlineKeyboardButton("üìù Convert Emoji to Text", callback_data='mode_decode')],
            [InlineKeyboardButton("üîÑ Auto Convert Mode", callback_data='mode_auto')],
            [InlineKeyboardButton("‚ùì Help", callback_data='help')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            "ü§ñ **Text to Emoji Converter Bot**\n\n"
            "Choose how you want to use the bot:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle regular text messages and auto-convert based on user mode"""
    if not update.message or not update.message.text or not update.message.from_user:
        return
        
    user_id = update.message.from_user.id
    text = update.message.text.strip()
    
    # Get user mode (default to auto)
    mode = user_modes.get(user_id, 'auto')
    
    if mode == 'encode':
        # Always encode in encode mode
        encoded = encode_text(text)
        await update.message.reply_text(encoded)
    elif mode == 'decode':
        # Always decode in decode mode
        decoded = decode_text(text)
        await update.message.reply_text(decoded)
    elif mode == 'auto':
        # Auto-detect and convert
        if is_emoji_text(text):
            # Convert emoji to text
            decoded = decode_text(text)
            await update.message.reply_text(decoded)
        else:
            # Convert text to emoji
            encoded = encode_text(text)
            await update.message.reply_text(encoded)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Send help message with back button"""
    if update.message:
        keyboard = [
            [InlineKeyboardButton("üîô Back to Menu", callback_data='back_to_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "üîß **How to Use This Bot**\n\n"
            "üîÆ **Text to Emoji:** Converts your text into secret emoji codes\n"
            "üìù **Emoji to Text:** Converts emoji codes back to readable text\n"
            "üîÑ **Auto Mode:** Automatically detects and converts both ways\n\n"
            "**Examples:**\n"
            "‚Ä¢ Text: 'hello' ‚Üí Emoji: 'üêöüîÆüçÑüçÑü¶¢'\n"
            "‚Ä¢ Emoji: 'üêöüîÆüçÑüçÑü¶¢' ‚Üí Text: 'hello'\n\n"
            "Just choose a mode and start typing!",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

async def encode_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Legacy encode command for backward compatibility"""
    if not update.message:
        return
        
    text = " ".join(context.args or [])
    if not text:
        await update.message.reply_text(
            "‚ùå Please provide text to encode.\n"
            "Usage: /encode your message here\n\n"
            "üí° Tip: Send /start to use the easy button interface!"
        )
        return
    
    try:
        encoded = encode_text(text)
        await update.message.reply_text(encoded)
    except Exception as e:
        logging.error(f"Error encoding text: {str(e)}")
        await update.message.reply_text("‚ùå An error occurred while encoding the text.")

async def decode_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Legacy decode command for backward compatibility"""
    if not update.message:
        return
        
    text = " ".join(context.args or [])
    if not text:
        await update.message.reply_text(
            "‚ùå Please provide emoji codes to decode.\n"
            "Usage: /decode üêöüîÆüçÑüçÑü¶¢\n\n"
            "üí° Tip: Send /start to use the easy button interface!"
        )
        return
    
    try:
        decoded = decode_text(text)
        await update.message.reply_text(decoded)
    except Exception as e:
        logging.error(f"Error decoding text: {str(e)}")
        await update.message.reply_text("‚ùå An error occurred while decoding the emoji codes.")

def main() -> None:
    """Start the bot."""
    # Get bot token from environment variable
    token = os.environ.get("TELEGRAM_BOT_TOKEN")
    
    if not token:
        print("‚ùå Error: TELEGRAM_BOT_TOKEN environment variable not set!")
        print("Please set your bot token using: export TELEGRAM_BOT_TOKEN=your_token_here")
        return
    
    # Create the Application
    application = Application.builder().token(token).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("encode", encode_command))
    application.add_handler(CommandHandler("decode", decode_command))
    application.add_handler(CallbackQueryHandler(button_handler))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Run the bot until the user presses Ctrl-C
    print("üöÄ Starting Telegram bot...")
    print("üéØ Bot ready! Users can now press /start to see the menu")
    print("Press Ctrl+C to stop the bot")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()